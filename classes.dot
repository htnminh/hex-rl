digraph "classes" {
rankdir=BT
charset="utf-8"
".T_destination" [color="#99DDFF", fontcolor="black", label=<{.T_destination|<br ALIGN="LEFT"/>|}>, shape="record", style="filled"];
".ndarray" [color="#99DDFF", fontcolor="black", label=<{.ndarray|T : ndarray<br ALIGN="LEFT"/>base : NoneType<br ALIGN="LEFT"/>ctypes : NoneType<br ALIGN="LEFT"/>data : NoneType<br ALIGN="LEFT"/>dtype : NoneType<br ALIGN="LEFT"/>flags : NoneType<br ALIGN="LEFT"/>flat : ndarray<br ALIGN="LEFT"/>imag : ndarray<br ALIGN="LEFT"/>itemsize : NoneType<br ALIGN="LEFT"/>nbytes : NoneType<br ALIGN="LEFT"/>ndim : NoneType<br ALIGN="LEFT"/>real : ndarray<br ALIGN="LEFT"/>shape : ndarray<br ALIGN="LEFT"/>size : NoneType<br ALIGN="LEFT"/>strides : NoneType<br ALIGN="LEFT"/>|all(axis, out, keepdims)<br ALIGN="LEFT"/>any(axis, out, keepdims)<br ALIGN="LEFT"/>argmax(axis, out)<br ALIGN="LEFT"/>argmin(axis, out)<br ALIGN="LEFT"/>argpartition(kth, axis, kind, order)<br ALIGN="LEFT"/>argsort(axis, kind, order)<br ALIGN="LEFT"/>astype(dtype, order, casting, subok, copy)<br ALIGN="LEFT"/>byteswap(inplace)<br ALIGN="LEFT"/>choose(choices, out, mode)<br ALIGN="LEFT"/>clip(min, max, out)<br ALIGN="LEFT"/>compress(condition, axis, out)<br ALIGN="LEFT"/>conj()<br ALIGN="LEFT"/>conjugate()<br ALIGN="LEFT"/>copy(order)<br ALIGN="LEFT"/>cumprod(axis, dtype, out)<br ALIGN="LEFT"/>cumsum(axis, dtype, out)<br ALIGN="LEFT"/>diagonal(offset, axis1, axis2)<br ALIGN="LEFT"/>dot(b, out)<br ALIGN="LEFT"/>dump(file)<br ALIGN="LEFT"/>dumps()<br ALIGN="LEFT"/>fill(value)<br ALIGN="LEFT"/>flatten(order)<br ALIGN="LEFT"/>getfield(dtype, offset)<br ALIGN="LEFT"/>item()<br ALIGN="LEFT"/>itemset()<br ALIGN="LEFT"/>max(axis, out)<br ALIGN="LEFT"/>mean(axis, dtype, out, keepdims)<br ALIGN="LEFT"/>min(axis, out, keepdims)<br ALIGN="LEFT"/>newbyteorder(new_order)<br ALIGN="LEFT"/>nonzero()<br ALIGN="LEFT"/>partition(kth, axis, kind, order)<br ALIGN="LEFT"/>prod(axis, dtype, out, keepdims)<br ALIGN="LEFT"/>ptp(axis, out)<br ALIGN="LEFT"/>put(indices, values, mode)<br ALIGN="LEFT"/>ravel(order)<br ALIGN="LEFT"/>repeat(repeats, axis)<br ALIGN="LEFT"/>reshape(shape, order)<br ALIGN="LEFT"/>resize(new_shape, refcheck)<br ALIGN="LEFT"/>round(decimals, out)<br ALIGN="LEFT"/>searchsorted(v, side, sorter)<br ALIGN="LEFT"/>setfield(val, dtype, offset)<br ALIGN="LEFT"/>setflags(write, align, uic)<br ALIGN="LEFT"/>sort(axis, kind, order)<br ALIGN="LEFT"/>squeeze(axis)<br ALIGN="LEFT"/>std(axis, dtype, out, ddof, keepdims)<br ALIGN="LEFT"/>sum(axis, dtype, out, keepdims)<br ALIGN="LEFT"/>swapaxes(axis1, axis2)<br ALIGN="LEFT"/>take(indices, axis, out, mode)<br ALIGN="LEFT"/>tobytes(order)<br ALIGN="LEFT"/>tofile(fid, sep, format)<br ALIGN="LEFT"/>tolist()<br ALIGN="LEFT"/>tostring(order)<br ALIGN="LEFT"/>trace(offset, axis1, axis2, dtype, out)<br ALIGN="LEFT"/>transpose()<br ALIGN="LEFT"/>var(axis, dtype, out, ddof, keepdims)<br ALIGN="LEFT"/>view(dtype, type)<br ALIGN="LEFT"/>}>, shape="record", style="filled"];
"gymnasium.core.Env" [color="#44BB99", fontcolor="black", label=<{gymnasium.core.Env|action_space : spaces.Space[ActType]<br ALIGN="LEFT"/>metadata : dict[str, Any]<br ALIGN="LEFT"/>np_random<br ALIGN="LEFT"/>observation_space : spaces.Space[ObsType]<br ALIGN="LEFT"/>render_mode : str \| None<br ALIGN="LEFT"/>reward_range : tuple<br ALIGN="LEFT"/>spec : EnvSpec \| None<br ALIGN="LEFT"/>unwrapped<br ALIGN="LEFT"/>|<I>close</I>()<br ALIGN="LEFT"/>get_wrapper_attr(name: str): Any<br ALIGN="LEFT"/><I>render</I>(): RenderFrame \| list[RenderFrame] \| None<br ALIGN="LEFT"/>reset(): tuple[ObsType, dict[str, Any]]<br ALIGN="LEFT"/><I>step</I>(action: ActType): tuple[ObsType, SupportsFloat, bool, bool, dict[str, Any]]<br ALIGN="LEFT"/>}>, shape="record", style="filled"];
"gymnasium.spaces.space.Space" [color="#BBCC33", fontcolor="black", label=<{gymnasium.spaces.space.Space|dtype : NoneType, dtype<br ALIGN="LEFT"/>is_np_flattenable<br ALIGN="LEFT"/>np_random<br ALIGN="LEFT"/>shape<br ALIGN="LEFT"/>|<I>contains</I>(x: Any): bool<br ALIGN="LEFT"/>from_jsonable(sample_n: list[Any]): list[T_cov]<br ALIGN="LEFT"/><I>sample</I>(mask: Any \| None): T_cov<br ALIGN="LEFT"/>seed(seed: int \| None): list[int]<br ALIGN="LEFT"/>to_jsonable(sample_n: Sequence[T_cov]): list[Any]<br ALIGN="LEFT"/>}>, shape="record", style="filled"];
"hex_rl.hex.Hex" [color="#77AADD", fontcolor="black", label=<{hex_rl.hex.Hex|LOWER_SIZE_LIMIT : int<br ALIGN="LEFT"/>UPPER_SIZE_LIMIT : int<br ALIGN="LEFT"/>board<br ALIGN="LEFT"/>inversed : bool<br ALIGN="LEFT"/>player : int<br ALIGN="LEFT"/>rich_exceptions : bool<br ALIGN="LEFT"/>size : int<br ALIGN="LEFT"/>winner : NoneType, int<br ALIGN="LEFT"/>|check_winner(): Optional[int]<br ALIGN="LEFT"/>get_char_player(): str<br ALIGN="LEFT"/>get_char_winner(): str<br ALIGN="LEFT"/>get_color_player(): str<br ALIGN="LEFT"/>get_color_winner(): str<br ALIGN="LEFT"/>get_rich_char_player(): str<br ALIGN="LEFT"/>get_rich_char_winner(): str<br ALIGN="LEFT"/>get_rich_color_player(): str<br ALIGN="LEFT"/>get_rich_color_winner(): str<br ALIGN="LEFT"/>get_rich_str(): str<br ALIGN="LEFT"/>get_winner_group(): Optional[set[tuple[int, int]]]<br ALIGN="LEFT"/>init_board(): np.ndarray<br ALIGN="LEFT"/>inverse(): None<br ALIGN="LEFT"/>is_valid_action(tup_action: tuple[int, int]): bool<br ALIGN="LEFT"/>play(tup_action: tuple[int, int]): None<br ALIGN="LEFT"/>player_int_to_char(player: int): str<br ALIGN="LEFT"/>player_int_to_color(player: int): str<br ALIGN="LEFT"/>player_int_to_rich_char(player: int): str<br ALIGN="LEFT"/>player_int_to_rich_color(player: int): str<br ALIGN="LEFT"/>reset(): None<br ALIGN="LEFT"/>rich_print(): None<br ALIGN="LEFT"/>}>, shape="record", style="filled"];
"hex_rl.hex.InvalidActionError" [color="#77AADD", fontcolor="red", label=<{hex_rl.hex.InvalidActionError|<br ALIGN="LEFT"/>|}>, shape="record", style="filled"];
"hex_rl.hex.InvalidSizeError" [color="#77AADD", fontcolor="red", label=<{hex_rl.hex.InvalidSizeError|<br ALIGN="LEFT"/>|}>, shape="record", style="filled"];
"hex_rl.hex.TerminatedError" [color="#77AADD", fontcolor="red", label=<{hex_rl.hex.TerminatedError|<br ALIGN="LEFT"/>|}>, shape="record", style="filled"];
"hex_rl.hex_cli_api.HexCLI" [color="#77AADD", fontcolor="black", label=<{hex_rl.hex_cli_api.HexCLI|<br ALIGN="LEFT"/>|play_pvp_cli(debug): int<br ALIGN="LEFT"/>print_prompt_and_play(): Tuple[int, int]<br ALIGN="LEFT"/>}>, shape="record", style="filled"];
"hex_rl.model_dqn.CustomCNN" [color="#77AADD", fontcolor="black", label=<{hex_rl.model_dqn.CustomCNN|cnn<br ALIGN="LEFT"/>|forward(observations)<br ALIGN="LEFT"/>}>, shape="record", style="filled"];
"hex_rl.model_dqn.DQNModel" [color="#77AADD", fontcolor="black", label=<{hex_rl.model_dqn.DQNModel|env<br ALIGN="LEFT"/>model<br ALIGN="LEFT"/>|load(path): None<br ALIGN="LEFT"/>predict(board)<br ALIGN="LEFT"/>predict_action(obs)<br ALIGN="LEFT"/>predict_inverse(board)<br ALIGN="LEFT"/>predict_q(obs)<br ALIGN="LEFT"/>save(path): None<br ALIGN="LEFT"/>train(total_timesteps): None<br ALIGN="LEFT"/>}>, shape="record", style="filled"];
"hex_rl.model_dqn.HexEnv" [color="#77AADD", fontcolor="black", label=<{hex_rl.model_dqn.HexEnv|action_space : Discrete<br ALIGN="LEFT"/>dqn_model : Optional[DQNModel]<br ALIGN="LEFT"/>hex<br ALIGN="LEFT"/>observation_space : Box<br ALIGN="LEFT"/>|render(mode)<br ALIGN="LEFT"/>reset(seed)<br ALIGN="LEFT"/>step(action, inverse)<br ALIGN="LEFT"/>}>, shape="record", style="filled"];
"hex_rl.model_random.RandomModel" [color="#77AADD", fontcolor="black", label=<{hex_rl.model_random.RandomModel|<br ALIGN="LEFT"/>|predict(board, info: dict)<br ALIGN="LEFT"/>}>, shape="record", style="filled"];
"hex_rl.pyg_button.Button" [color="#77AADD", fontcolor="black", label=<{hex_rl.pyg_button.Button|colour : Tuple[int, int, int]<br ALIGN="LEFT"/>font<br ALIGN="LEFT"/>font_size : int<br ALIGN="LEFT"/>highlight_colour<br ALIGN="LEFT"/>highlight_offset : int<br ALIGN="LEFT"/>highlight_tick : int<br ALIGN="LEFT"/>max_highlight_ticks : int<br ALIGN="LEFT"/>text : str<br ALIGN="LEFT"/>text_colour : Tuple[int, int, int]<br ALIGN="LEFT"/>text_rect<br ALIGN="LEFT"/>text_render<br ALIGN="LEFT"/>x : float<br ALIGN="LEFT"/>y : float<br ALIGN="LEFT"/>|is_collide(mouse_pos)<br ALIGN="LEFT"/>render(screen)<br ALIGN="LEFT"/>render_highlight(): None<br ALIGN="LEFT"/>update()<br ALIGN="LEFT"/>}>, shape="record", style="filled"];
"hex_rl.pyg_button.TextButton" [color="#77AADD", fontcolor="black", label=<{hex_rl.pyg_button.TextButton|highlight_colour<br ALIGN="LEFT"/>text : str<br ALIGN="LEFT"/>|update_text(new_text: str): None<br ALIGN="LEFT"/>}>, shape="record", style="filled"];
"hex_rl.pyg_hexagon.HexagonTile" [color="#77AADD", fontcolor="black", label=<{hex_rl.pyg_hexagon.HexagonTile|centre<br ALIGN="LEFT"/>colour : Tuple[int, ...]<br ALIGN="LEFT"/>highlight_colour<br ALIGN="LEFT"/>highlight_offset : int<br ALIGN="LEFT"/>highlight_tick : int<br ALIGN="LEFT"/>max_highlight_ticks : int<br ALIGN="LEFT"/>minimal_radius<br ALIGN="LEFT"/>player : NoneType<br ALIGN="LEFT"/>position : Tuple[float, float]<br ALIGN="LEFT"/>radius : float<br ALIGN="LEFT"/>vertices : list<br ALIGN="LEFT"/>|collide_with_point(point: Tuple[float, float]): bool<br ALIGN="LEFT"/>compute_neighbours(hexagons: List[HexagonTile]): List[HexagonTile]<br ALIGN="LEFT"/>compute_vertices(): List[Tuple[float, float]]<br ALIGN="LEFT"/>is_neighbour(hexagon: HexagonTile): bool<br ALIGN="LEFT"/>mark_winner_group(screen): None<br ALIGN="LEFT"/>play(player): None<br ALIGN="LEFT"/>render(screen): None<br ALIGN="LEFT"/>render_highlight(): None<br ALIGN="LEFT"/>update()<br ALIGN="LEFT"/>}>, shape="record", style="filled"];
"hex_rl.pyg_hexagrid.HexagonGrid" [color="#77AADD", fontcolor="black", label=<{hex_rl.pyg_hexagrid.HexagonGrid|agent_1 : Optional[str]<br ALIGN="LEFT"/>agent_2 : Optional[str]<br ALIGN="LEFT"/>caption : str<br ALIGN="LEFT"/>color_edge_width : int<br ALIGN="LEFT"/>colour : tuple<br ALIGN="LEFT"/>init_position : tuple<br ALIGN="LEFT"/>mode : Optional[str]<br ALIGN="LEFT"/>radius : int<br ALIGN="LEFT"/>screen_fill_colour : tuple<br ALIGN="LEFT"/>screen_size : tuple<br ALIGN="LEFT"/>size : Optional[int]<br ALIGN="LEFT"/>|init_buttons(text): List[Button]<br ALIGN="LEFT"/>init_hexagons(): List[List[HexagonTile]]<br ALIGN="LEFT"/>init_info_text(text)<br ALIGN="LEFT"/>main()<br ALIGN="LEFT"/>render_buttons(screen, buttons)<br ALIGN="LEFT"/>render_hexagrid(screen, hexagons, winner_group)<br ALIGN="LEFT"/>render_info_text(screen, info_text)<br ALIGN="LEFT"/>}>, shape="record", style="filled"];
"pygame.ftfont.Font" [color="#AAAA00", fontcolor="black", label=<{pygame.ftfont.Font|antialiased<br ALIGN="LEFT"/>bold<br ALIGN="LEFT"/>italic<br ALIGN="LEFT"/>kerning : bool<br ALIGN="LEFT"/>oblique<br ALIGN="LEFT"/>origin : bool<br ALIGN="LEFT"/>pad : bool<br ALIGN="LEFT"/>strength : float<br ALIGN="LEFT"/>ucs4 : bool<br ALIGN="LEFT"/>underline<br ALIGN="LEFT"/>underline_adjustment : float<br ALIGN="LEFT"/>wide<br ALIGN="LEFT"/>|get_ascent()<br ALIGN="LEFT"/>get_bold()<br ALIGN="LEFT"/>get_descent()<br ALIGN="LEFT"/>get_height()<br ALIGN="LEFT"/>get_italic()<br ALIGN="LEFT"/>get_linesize()<br ALIGN="LEFT"/>get_underline()<br ALIGN="LEFT"/>metrics(text)<br ALIGN="LEFT"/>render(text, antialias, color, background)<br ALIGN="LEFT"/>set_bold(value)<br ALIGN="LEFT"/>set_italic(value)<br ALIGN="LEFT"/>set_underline(value)<br ALIGN="LEFT"/>size(text)<br ALIGN="LEFT"/>}>, shape="record", style="filled"];
"stable_baselines3.common.base_class.BaseAlgorithm" [color="#EEDD88", fontcolor="black", label=<{stable_baselines3.common.base_class.BaseAlgorithm|action_noise : Optional[ActionNoise]<br ALIGN="LEFT"/>action_space<br ALIGN="LEFT"/>device : device<br ALIGN="LEFT"/>env : Optional[VecEnv], Union<br ALIGN="LEFT"/>ep_info_buffer : NoneType, deque<br ALIGN="LEFT"/>ep_success_buffer : NoneType, deque<br ALIGN="LEFT"/>learning_rate : Union[float, Schedule]<br ALIGN="LEFT"/>logger<br ALIGN="LEFT"/>lr_schedule : Callable<br ALIGN="LEFT"/>n_envs : int<br ALIGN="LEFT"/>num_timesteps : int<br ALIGN="LEFT"/>observation_space<br ALIGN="LEFT"/>policy : BasePolicy<br ALIGN="LEFT"/>policy_aliases : ClassVar[Dict[str, Type[BasePolicy]]]<br ALIGN="LEFT"/>policy_class<br ALIGN="LEFT"/>policy_kwargs : NoneType, dict<br ALIGN="LEFT"/>sde_sample_freq : int<br ALIGN="LEFT"/>seed : Optional[int]<br ALIGN="LEFT"/>start_time : float<br ALIGN="LEFT"/>tensorboard_log : Optional[str]<br ALIGN="LEFT"/>use_sde : bool<br ALIGN="LEFT"/>verbose : int<br ALIGN="LEFT"/>|get_env(): Optional[VecEnv]<br ALIGN="LEFT"/>get_parameters(): Dict[str, Dict]<br ALIGN="LEFT"/>get_vec_normalize_env(): Optional[VecNormalize]<br ALIGN="LEFT"/><I>learn</I>(total_timesteps: int, callback: MaybeCallback, log_interval: int, tb_log_name: str, reset_num_timesteps: bool, progress_bar: bool): SelfBaseAlgorithm<br ALIGN="LEFT"/>load(path: Union[str, pathlib.Path, io.BufferedIOBase], env: Optional[GymEnv], device: Union[th.device, str], custom_objects: Optional[Dict[str, Any]], print_system_info: bool, force_reset: bool): SelfBaseAlgorithm<br ALIGN="LEFT"/>predict(observation: Union[np.ndarray, Dict[str, np.ndarray]], state: Optional[Tuple[np.ndarray, ...]], episode_start: Optional[np.ndarray], deterministic: bool): Tuple[np.ndarray, Optional[Tuple[np.ndarray, ...]]]<br ALIGN="LEFT"/>save(path: Union[str, pathlib.Path, io.BufferedIOBase], exclude: Optional[Iterable[str]], include: Optional[Iterable[str]]): None<br ALIGN="LEFT"/>set_env(env: GymEnv, force_reset: bool): None<br ALIGN="LEFT"/>set_logger(logger: Logger): None<br ALIGN="LEFT"/>set_parameters(load_path_or_dict: Union[str, TensorDict], exact_match: bool, device: Union[th.device, str]): None<br ALIGN="LEFT"/>set_random_seed(seed: Optional[int]): None<br ALIGN="LEFT"/>}>, shape="record", style="filled"];
"stable_baselines3.common.off_policy_algorithm.OffPolicyAlgorithm" [color="#EEDD88", fontcolor="black", label=<{stable_baselines3.common.off_policy_algorithm.OffPolicyAlgorithm|action_noise : Optional[ActionNoise], VectorizedActionNoise<br ALIGN="LEFT"/>actor<br ALIGN="LEFT"/>batch_size : int<br ALIGN="LEFT"/>buffer_size : int<br ALIGN="LEFT"/>gamma : float<br ALIGN="LEFT"/>gradient_steps : int<br ALIGN="LEFT"/>learning_starts : int<br ALIGN="LEFT"/>num_timesteps<br ALIGN="LEFT"/>optimize_memory_usage : bool<br ALIGN="LEFT"/>policy<br ALIGN="LEFT"/>replay_buffer : DictReplayBuffer, Optional[ReplayBuffer]<br ALIGN="LEFT"/>replay_buffer_class : DictReplayBuffer, Optional[Type[ReplayBuffer]]<br ALIGN="LEFT"/>replay_buffer_kwargs : dict<br ALIGN="LEFT"/>tau : float<br ALIGN="LEFT"/>train_freq : TrainFreq, Union[int, Tuple[int, str]]<br ALIGN="LEFT"/>use_sde_at_warmup : bool<br ALIGN="LEFT"/>|collect_rollouts(env: VecEnv, callback: BaseCallback, train_freq: TrainFreq, replay_buffer: ReplayBuffer, action_noise: Optional[ActionNoise], learning_starts: int, log_interval: Optional[int]): RolloutReturn<br ALIGN="LEFT"/>learn(total_timesteps: int, callback: MaybeCallback, log_interval: int, tb_log_name: str, reset_num_timesteps: bool, progress_bar: bool): SelfOffPolicyAlgorithm<br ALIGN="LEFT"/>load_replay_buffer(path: Union[str, pathlib.Path, io.BufferedIOBase], truncate_last_traj: bool): None<br ALIGN="LEFT"/>save_replay_buffer(path: Union[str, pathlib.Path, io.BufferedIOBase]): None<br ALIGN="LEFT"/><I>train</I>(gradient_steps: int, batch_size: int): None<br ALIGN="LEFT"/>}>, shape="record", style="filled"];
"stable_baselines3.common.torch_layers.BaseFeaturesExtractor" [color="#EEDD88", fontcolor="black", label=<{stable_baselines3.common.torch_layers.BaseFeaturesExtractor|features_dim<br ALIGN="LEFT"/>|}>, shape="record", style="filled"];
"stable_baselines3.dqn.dqn.DQN" [color="#EE8866", fontcolor="black", label=<{stable_baselines3.dqn.dqn.DQN|batch_norm_stats<br ALIGN="LEFT"/>batch_norm_stats_target<br ALIGN="LEFT"/>exploration_final_eps : float<br ALIGN="LEFT"/>exploration_fraction : float<br ALIGN="LEFT"/>exploration_initial_eps : float<br ALIGN="LEFT"/>exploration_rate : float<br ALIGN="LEFT"/>exploration_schedule : Callable<br ALIGN="LEFT"/>max_grad_norm : float<br ALIGN="LEFT"/>policy : DQNPolicy<br ALIGN="LEFT"/>policy_aliases : ClassVar[Dict[str, Type[BasePolicy]]]<br ALIGN="LEFT"/>q_net : QNetwork<br ALIGN="LEFT"/>q_net_target : QNetwork<br ALIGN="LEFT"/>target_update_interval : int<br ALIGN="LEFT"/>|learn(total_timesteps: int, callback: MaybeCallback, log_interval: int, tb_log_name: str, reset_num_timesteps: bool, progress_bar: bool): SelfDQN<br ALIGN="LEFT"/>predict(observation: Union[np.ndarray, Dict[str, np.ndarray]], state: Optional[Tuple[np.ndarray, ...]], episode_start: Optional[np.ndarray], deterministic: bool): Tuple[np.ndarray, Optional[Tuple[np.ndarray, ...]]]<br ALIGN="LEFT"/>train(gradient_steps: int, batch_size: int): None<br ALIGN="LEFT"/>}>, shape="record", style="filled"];
"torch._dynamo.eval_frame.OptimizedModule" [color="#FFAABB", fontcolor="black", label=<{torch._dynamo.eval_frame.OptimizedModule|dynamo_ctx<br ALIGN="LEFT"/>forward<br ALIGN="LEFT"/>get_compiler_config : Callable[[], Any]<br ALIGN="LEFT"/>|}>, shape="record", style="filled"];
"torch.nn.modules.container.Sequential" [color="#DDDDDD", fontcolor="black", label=<{torch.nn.modules.container.Sequential|<br ALIGN="LEFT"/>|append(module: Module): 'Sequential'<br ALIGN="LEFT"/>extend(sequential): 'Sequential'<br ALIGN="LEFT"/>forward(input)<br ALIGN="LEFT"/>insert(index: int, module: Module): 'Sequential'<br ALIGN="LEFT"/>pop(key: Union[int, slice]): Module<br ALIGN="LEFT"/>}>, shape="record", style="filled"];
"torch.nn.modules.module.Module" [color="#DDDDDD", fontcolor="black", label=<{torch.nn.modules.module.Module|T_destination<br ALIGN="LEFT"/>call_super_init : bool<br ALIGN="LEFT"/>dump_patches : bool<br ALIGN="LEFT"/>forward : Callable[..., Any]<br ALIGN="LEFT"/>training : bool<br ALIGN="LEFT"/>|add_module(name: str, module: Optional['Module']): None<br ALIGN="LEFT"/>apply(fn: Callable[['Module'], None]): T<br ALIGN="LEFT"/>bfloat16(): T<br ALIGN="LEFT"/>buffers(recurse: bool): Iterator[Tensor]<br ALIGN="LEFT"/>children(): Iterator['Module']<br ALIGN="LEFT"/>compile()<br ALIGN="LEFT"/>cpu(): T<br ALIGN="LEFT"/>cuda(device: Optional[Union[int, device]]): T<br ALIGN="LEFT"/>double(): T<br ALIGN="LEFT"/>eval(): T<br ALIGN="LEFT"/>extra_repr(): str<br ALIGN="LEFT"/>float(): T<br ALIGN="LEFT"/>get_buffer(target: str): 'Tensor'<br ALIGN="LEFT"/>get_extra_state(): Any<br ALIGN="LEFT"/>get_parameter(target: str): 'Parameter'<br ALIGN="LEFT"/>get_submodule(target: str): 'Module'<br ALIGN="LEFT"/>half(): T<br ALIGN="LEFT"/>ipu(device: Optional[Union[int, device]]): T<br ALIGN="LEFT"/>load_state_dict(state_dict: Mapping[str, Any], strict: bool, assign: bool)<br ALIGN="LEFT"/>modules(): Iterator['Module']<br ALIGN="LEFT"/>named_buffers(prefix: str, recurse: bool, remove_duplicate: bool): Iterator[Tuple[str, Tensor]]<br ALIGN="LEFT"/>named_children(): Iterator[Tuple[str, 'Module']]<br ALIGN="LEFT"/>named_modules(memo: Optional[Set['Module']], prefix: str, remove_duplicate: bool)<br ALIGN="LEFT"/>named_parameters(prefix: str, recurse: bool, remove_duplicate: bool): Iterator[Tuple[str, Parameter]]<br ALIGN="LEFT"/>parameters(recurse: bool): Iterator[Parameter]<br ALIGN="LEFT"/>register_backward_hook(hook: Callable[['Module', _grad_t, _grad_t], Union[None, _grad_t]]): RemovableHandle<br ALIGN="LEFT"/>register_buffer(name: str, tensor: Optional[Tensor], persistent: bool): None<br ALIGN="LEFT"/>register_forward_hook(hook: Union[Callable[[T, Tuple[Any, ...], Any], Optional[Any]], Callable[[T, Tuple[Any, ...], Dict[str, Any], Any], Optional[Any]]]): RemovableHandle<br ALIGN="LEFT"/>register_forward_pre_hook(hook: Union[Callable[[T, Tuple[Any, ...]], Optional[Any]], Callable[[T, Tuple[Any, ...], Dict[str, Any]], Optional[Tuple[Any, Dict[str, Any]]]]]): RemovableHandle<br ALIGN="LEFT"/>register_full_backward_hook(hook: Callable[['Module', _grad_t, _grad_t], Union[None, _grad_t]], prepend: bool): RemovableHandle<br ALIGN="LEFT"/>register_full_backward_pre_hook(hook: Callable[['Module', _grad_t], Union[None, _grad_t]], prepend: bool): RemovableHandle<br ALIGN="LEFT"/>register_load_state_dict_post_hook(hook)<br ALIGN="LEFT"/>register_module(name: str, module: Optional['Module']): None<br ALIGN="LEFT"/>register_parameter(name: str, param: Optional[Parameter]): None<br ALIGN="LEFT"/>register_state_dict_pre_hook(hook)<br ALIGN="LEFT"/>requires_grad_(requires_grad: bool): T<br ALIGN="LEFT"/>set_extra_state(state: Any): None<br ALIGN="LEFT"/>share_memory(): T<br ALIGN="LEFT"/>state_dict(): T_destination<br ALIGN="LEFT"/>to(device: Optional[DeviceLikeType], dtype: Optional[dtype], non_blocking: bool): Self<br ALIGN="LEFT"/>to_empty(): T<br ALIGN="LEFT"/>train(mode: bool): T<br ALIGN="LEFT"/>type(dst_type: Union[dtype, str]): T<br ALIGN="LEFT"/>xpu(device: Optional[Union[int, device]]): T<br ALIGN="LEFT"/>zero_grad(set_to_none: bool): None<br ALIGN="LEFT"/>}>, shape="record", style="filled"];
"hex_rl.model_dqn.CustomCNN" -> "stable_baselines3.common.torch_layers.BaseFeaturesExtractor" [arrowhead="empty", arrowtail="none"];
"hex_rl.model_dqn.HexEnv" -> "gymnasium.core.Env" [arrowhead="empty", arrowtail="none"];
"hex_rl.pyg_button.TextButton" -> "hex_rl.pyg_button.Button" [arrowhead="empty", arrowtail="none"];
"stable_baselines3.common.off_policy_algorithm.OffPolicyAlgorithm" -> "stable_baselines3.common.base_class.BaseAlgorithm" [arrowhead="empty", arrowtail="none"];
"stable_baselines3.common.torch_layers.BaseFeaturesExtractor" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"stable_baselines3.dqn.dqn.DQN" -> "stable_baselines3.common.off_policy_algorithm.OffPolicyAlgorithm" [arrowhead="empty", arrowtail="none"];
"torch._dynamo.eval_frame.OptimizedModule" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
"torch.nn.modules.container.Sequential" -> "torch.nn.modules.module.Module" [arrowhead="empty", arrowtail="none"];
".T_destination" -> "torch.nn.modules.module.Module" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="T_destination", style="solid"];
".ndarray" -> "hex_rl.hex.Hex" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="board", style="solid"];
"hex_rl.model_dqn.HexEnv" -> "hex_rl.model_dqn.DQNModel" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="env", style="solid"];
"pygame.ftfont.Font" -> "hex_rl.pyg_button.Button" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="font", style="solid"];
"stable_baselines3.dqn.dqn.DQN" -> "hex_rl.model_dqn.DQNModel" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="model", style="solid"];
"stable_baselines3.dqn.dqn.DQN" -> "hex_rl.model_dqn.DQNModel" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="model", style="solid"];
"torch._dynamo.eval_frame.OptimizedModule" -> "torch.nn.modules.module.Module" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_compiled_call_impl", style="solid"];
"torch.nn.modules.container.Sequential" -> "hex_rl.model_dqn.CustomCNN" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cnn", style="solid"];
"torch.nn.modules.module.Module" -> "stable_baselines3.common.off_policy_algorithm.OffPolicyAlgorithm" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="actor", style="solid"];
"gymnasium.spaces.space.Space" -> "stable_baselines3.common.torch_layers.BaseFeaturesExtractor" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_observation_space", style="solid"];
"torch.nn.modules.module.Module" -> "torch._dynamo.eval_frame.OptimizedModule" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_orig_mod", style="solid"];
}
